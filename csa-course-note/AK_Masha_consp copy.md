Универсальный процессор. Машина фон Неймана. Принципы DataPath. Гарвард и Принстон

1.
(слайды)
Информационный процессор
- система (электрическая, механическая или биологическая), которая принимает информацию (последовательность символов или состояний) в одной форме и обрабатывает (преобразует) ее в другую форму

Например: исходный сигнал в статистику, посредством алгоритмического процесса.

Инф. проц. включает:
1. ввод
2. процессор
3. хранилище
4. вывод

(сам сказал)
инф. проц - общее название процессора, который может обрабатывать информацию. то то чем мы говорили на прошлой лекции, когда вводили понятие двухэтапного производства, где у нас система разбивается на две части: на некоторый вычислитель и его конфигурацию который определяет то как он работает
- собственно информационный процессор - это такая очень простая абстракция которая нам позволяет охарактеризовать любой процессор э относительно универсальный то есть подразумевающий в том или ином виде программирование конфигурирования который может обрабатывать данные 

понятие в общем-то больше абстрактное чем практически значимое но тем не менее оно нам позволяет зафиксировать четыре составляющие любого процессора с которым вы так или иначе будете работать потому что там есть вырожденные случаи когда отдельный пункт может выпасть но по большому счёту это всё необходимо первое - это вот потому что для того чтобы процессор работал надо чтобы о нём откуда-то появилась информация которую он будет обрабатывать второе - это собственно сам процессор то есть некоторые 

00:00:01	компьютер итак в этом тесте были следующие вопросы харве софtare означает: выберите правильное утверждение а 113 ребят ответили: "Харда твёрдо сколько сложно изменить софт мягко и легко изменить" ну ребята надо на лекции ходить тогда не будете так косячить а модель вычисления не является частичными синонимами для паттернов проектирования совершенно верно паттерны проектирования - это больше про инструкции бедным разработчикам чем про собственно реализацию в отзыве на тему семинара написа написали что нужна конкретика

00:00:41	на самом деле этот вопрос был добавлен после очередной боли когда проверялись ваши темы семинаров и прям хотелось кого-то из вас придушить а поскольку этот ревью тем идёт анонимизировано то есть я не знаю кого я ревью только группу придушить некого но очень хотелось а вот на тему семинара написали что нужна конкретика на примере алгоритмов кэше функции лучше написать ну то есть у вас где-то есть пункт полезное что я расскажу или я расскажу там про хэш-функции как добавить в этот тезис конкретика справилось с этим

00:01:18	тезисом только 35 человек первый ответ будут рассмотрены наиболее распространённые функции ну бред бредовый второй пункт будут рассмотрены конкретные функции огромное количество ваших коллег так и пишут и почему-то вы свято верите что если написано что конкретные функции будут рассмотрены то в этом есть какая-то содержательная часть практика показывает что нет нету как бы усилить акцентом не прокатит особенно в текстовой форме третий вариант будут рассмотрены функции которые используются в реальных системах

00:01:51	пять человек вы не правы третий ответ рассмотрим MD5 США1 и США 256 вот это правильный ответ почему потому что в нём конкретно сказано что вы рассмотрите вы определяете скоп вашего доклада и нету ненужных слов 197 человек ответили: "Рассмотрим быстрые функции такие как МД а также криптостойки США1 все сторонни проанализировав их практическую значимость огромное количество воды налито текст такой читать проверять сложно а содержатесь на части в этом ну банально нет поэтому это неправильный ответ компактно и по существу

00:02:34	конкретика следующий вопрос согласно определению MG Essence в программную систему не включается методическое обеспечение 192 человека были правы машина тюнинга является абстрактным вычислителем так как 102 никто не думал реализовывать её на практике ну ошибаетесь потому что частичных реализаций машин тюринга оченьоченьочень много аа реальный ответ: 99 человек были правы лента слишком сложна в реализации ну слишком сложна в данном случае означает невозможно к реализации потому что она должна быть

00:03:10	бесконечной а какие преимущества представляет хардве софтведизайн в сравнении с традиционными методами разработки 223 человека были правы сказав что все указаны а-а собственно это всё едем дальше перед тем как начать лекционную часть Яславл Георгиевич просил вам передать что вы удивительные молодцы вас под сотню человек пришло посмотреть на экскурсию на производство в прошлые годы обычно там было человек по 50-60 в общем второй практик очень доволен вами и придавал вам респекты аа дарма Роман извините а вы можете на второй

00:03:58	вопрос ещё раз встат пожалуйста сказать можете пересмотреть давайте не побежим вперёд о'кей оно всё-таки есть в записи итак сегодня начинается уберлекция уберлекция потому что практика показывает что обычно рассказывается за два-три занятия это лекция которая вводит вас собственно в понятие машины Фонеймона и вообще в базовую историю про то какие бывают процессора и как они работают вот те процессора которые стоят в компьютерах перед нами вернее их простенькие варианты какие-то такие минимальные

00:04:36	версии после этого уже после вот этих трёх лекций с моей точки зрения вы должны более или менее всё знать всё понимать про своей процессора суметь отвечать на все вопросы по LAAB 3 и быть полностью готовы к тому чтобы сделать закончить завершить LAAB 4 потому что ну по большому счёту основная часть материала будет дана дальше там будут уже довольно частные случаи такие как а вотвы такие как иерархия памяти со всякими кошами и о я размахиваю сижу руками а картинку включить забыл а то как работает подсистема памяти и уходы в

00:05:17	разные вопросики экзотики которые имеют место быть в реальных процессорах потому что как к счастью машина - это не всё что у нас есть итак поехали а первое с чего хочется начать - это ввести понятие информационного процессора и универсального процессора аа так как ну по большому счёту это такая теоретическая подготовка для того чтобы потом занырнуть настоящую реализации настоящей истории а что такое информационный процессор это общее название такого аа процессора который может обрабатывать информацию то есть то

00:05:56	о чём мы с вами например говорили на прошлой лекции когда вводили понятие двухэтапного производства где у нас система разбивается на две части на некоторый вычислитель и его конфигурацию которая определяет то как он работает собственно информационный процессор - это такая очень простая абстракция которая нам позволяет охарактеризовать любой процессор э относительно универсальный то есть подразумевающий в том или ином виде программирование конфигурирования который может обрабатывать данные собственно

00:06:26	понятие в общем-то больше абстрактное чем практически значимое но тем не менее оно нам позволяет зафиксировать четыре составляющие любого процессора с которым вы так или иначе будете работать потому что там есть вырожденные случаи когда отдельный пункт может выпасть но по большому счёту это всё необходимо первое - это вот потому что для того чтобы процессор работал надо чтобы о нём откуда-то появилась информация которую он будет обрабатывать второе - это собственно сам процессор то есть некоторые

00:07:00	вычислительные механизмы которые позволяют вам разворачивать вычислительный процесс во времени как-то корректировать менять влиять а на ту информацию которая через него протаскивается хранилище а теоретически оно может быть вырожденным но на практике любой сколько-нибудь значимый процессор в том или ином виде будет вас хранить ту информацию которую он обрабатывает он не сможет это сделать мгновенно и сразу технически даже если мы возьмём просто цифровую комбинационную схему мы можем говорить о том что провода хранят те

00:07:31	данные которые в ней обрабатываются вот эти промежуточные состояния которые в ней имеют место быть а и последнее - это вывод наверное вывод то без чего ну совсем никак не может быть потому что процессор в простейшем случае он может быть вырожден в повторитель то есть кусок провода а хранилище там теоретически тоже может не быть но вывод вам всё равно нужен если вы не хотите просто нагревательный прибор самый реалистичный кусок который из этого процессора может выпадать - это конечно же вот потому что у вас есть

00:08:03	тактовый генератор который притянуто за уши но является процессором у вас есть там генераторы случайных чисел у вас могут быть численные задачи когда входные данные у вас в компилируются в сам процесс ваш само хранилище и результат работы является какой-то статически повторяемый данные ну допустим программа которую вы написали для расчёта числа пи вам входа в неё не нужно если вы там будете считать а чиселки бесконечно и до конца а от информационного процессора дальше поскольку само по себе понятие

00:08:42	информационный процессор оно не особенно фиксирует относительно того может оно программироваться или нет мы втащим сейчас понятие и поговорим про понятие универсального процессора то есть такой процессор который работает в рамках э двухэтапного производства и который у вас может быть специализирован по ту практическую задачу которую вы сейчас решаете а сразу же надо там навесить кучу дисклеймеров во-первых дальше по большому счёту почти весь курс мы будем говорить про универсальных процессорах универсальность конечно ограниченная но

00:09:16	про универсальные процессора первый пункт универсальность не значит что ваш процессор должен быть полн по тюривингу а универсальность имеется в виду какой-то рук задач а например а языки есть языки программирования не полные по тюрингу но те которые позволяют решать практические задачи достаточно большого круга а например такие языки как Агда Идрис ориентированы на сейчас помню это слово на статическую верификацию кода которую вы написали на формальный анализ того кода который вы написали второй

00:09:48	пункт теоретическая универсальность не говорит о практической универсальности два наверное самых классных примера это машина тюринга и это пример четвёртого батонной работы а именно язык бinf теоретически и то и другое являются учительными машинами но реализовать сколько-нибудь сложные реальные алгоритмы на нём это может быть разделом как сказать а-а разделом для того чтобы поломать себе голову но это не может быть ээ ну практической историей в том плане что это упражнение для ума но не фактическая

00:10:26	деятельность третий пункт универсальность противоречит эффективности и дальше там через слайд через два мы как раз на этом сфокусируем внимание практически всегда чем универсальней ваш процессор тем хуже у него с эффективностью работы ну и обратное тоже справедливо хотя там с оговорками а самый простой пример у вас есть специализированная схема под задачу которая вообще не универсальна потому что она как сказать э вытащена в кремни и будет функционировать именно так соответствует своей схемы как есть и альтернатива -

00:11:06	это процессорна уровень энергопотребления и скорость работы у них обычно несопоставимы и четвёртое современный процессор - это почти всегда совокупность програмное обеспечение мы об этом уже много раз упоминали и даже будем рассматривать микропрограммное управление ещё раз более подробно для того чтобы м ну как скажем так с одной стороны вы понимали как это устроено как это работает лучше и с другой стороны те ребята которые будут прототипировать это в четвёртой лабораторке смогут получить нужную для

00:11:36	этой информацию а какие свойства мы можем выделить у универсального процессора для того чтобы он собственно был универсальным первое - это двухэтапное производство мы разделяем жизненный цикл нашего процессора на момент производства самого процессора и на момент того как он будет эксплуатироваться для решения практических задач второе - это как правило полнота по тюрингу то есть он не обязательно должен быть но универсальный процессор в общем случае мы вынуждены туда подтягивать третье отсутствие

00:12:06	серьёзных исключений на объём программы ну понятное дело что если у вас объём памяти команд 1 Кб вы не сможете тамть ничего сложного ну четвёртый пункт как подголосок первого - это изменяемость программы сопещения после его реализации есть какие-то вопросики итак видам процессоров а собственно здесь показано два графика которые собирают в себе разные процессорные архитектуры виды процессоров вот именно в широком смысле не как процессор который у вас в компьютере а вот в широком классе на графичках где левый график он показывает

00:12:50	по горизонтали а гибкость программируемость то есть насколько вы можете на втором этапе поменять их функциональность а по вертикали показывает энергетическую эффективность ну то есть грубо говоря вам нужно там решить какую-то численную задачку сколько электроэнергии вы на неё потратите там при прочих равных здесь вы можете видеть ASIC - это кремневое производство это э большие интегральные схемы сверхбольшие интегральные схемы в русском переводе дальше идёт группа из FPG fpga и CGRA это способ программной реализации схем

00:13:35	что такое CGray мы поговорим ближе к концу курса это такие хитрые вычислители которые сейчас ну скажем так их перспективность была видна всегда но сейчас мы пришли к тому что к сожалению их уже нужно реализовывать на практике дальше идёт тут графические процессора а сигна сигнальные процессора и CPU соответственно мы с вами в этом курсе про AC там в двух словах что это такое мы с вами уже поговорили про FPG и CJR поговорим в конце курса а GPU чем он отличается от CPU какое неустроенное тоже поговорим в конце курса а сейчас мы

00:14:11	сосреточимся на CPU класс сигнальных процессоров по большому счёту мы его скорее с вами обойдём аккуратно бочком а просто потому что ну нам и так хватит материала соответственно здесь вы можете видеть что всё загибается по дуге уходя в универсальность мы получаем низкое энергопотребление высокое энергопотребление уходя в специально лизированное железо мы получаем энергоэффективность м задача проектировщиков аппаратуры по большому счёту сводится к тому что определяется какой уровень гибкости нужен и вот этот

00:14:47	баланс с энергоэффективностью в правой части показано примерно то же самое э только по горизонтали вместо гибкости продемонстрирована производительность то есть грубо говоря сколько единиц операций может быть выполнено на единицу энергии ну и собственно здесь так сказать практически симметричный график я не могу вам точно сказать с чем связаны вот эти вот тонкие различия но по большому счёту интуитивно их можно видеть соответственно мы с вами будем сейчас в ближайших лекций 4-5 говорить про Central Process Unit и про то какие

00:15:24	они бывают альтернативная точка зрения то есть которая по сути показывает то же самое но с другой точки зрения немножко это сравнение разных видов процессоров с точки зрения того как они программируются а на какой платформе они сказаны и как следствие уровень как скажем так отличий между тем учрежденым процессом который у вас происходит в физике в реальном мире и той моделью которая есть то есть опять-таки возвращаемся к прошлой лекции как по концепции модели вычислений и то как у вас модель вычисления может быть

00:15:56	отображена в тот вычислительный базис который у вас есть и здесь что мы с вами видим а в нижнем уровне мы видим всё те же названия процессоров риск в данном случае можно заметь условно на CPU FPGA DSP ACIP AIC разные классы процессоров понятное дело что уровень гибкости растёт к левой части собственно вот это на оси подписано domain specific аналогично то есть под доме специфиic имеется в виду специализация инструмента под какой-то конкретный класс задач в случае с Эйсиком это очень часто бывает

00:16:32	истории м считаем хэш-функции потому что мы хотим майнить биткои здесь а хотим майнить биткоине биткоины майним биткоины не хотим там не знаю играем в игрушки верхняя часть показывает то где расписаны те языки на которых происходит то самое программирование на языках высокого уровня - это условный си дальше идёт спуск к аппарат языкам описания аппаратуры к машинным языкам ну и собственно HDL AC по большому счёту это сводится к тому что вы практически впрямую описываете ту схему которая есть только в текстовой форме и она начинает

00:17:10	у вас работать собственно вот она вилка выбора учительной платформ о которой идёт речь мы сейчас с вами будем говорить опять-таки о крайне левой о том как работают процессора аа что является главной характеристикой работы любого процессора это его архитектура или по крайней мере есть устоявшийся термин о том что такое архитектура процессор это немножко оно немножко отличается от того что понимается под архитектурой в целом там архитектура программной системы архитектура системы в целом а когда мы

00:17:42	говорим про процессор и про его архитектуру мы практически всегда с вами говорим о его интерфейсе к программисту то есть какие возможности есть у бедного программиста для того чтобы реализовывать свои задачи то есть набор инструкций аа то как он их может как они будут выполняться какие он может ли он явно разыскать какие инструкции будут параллельны или только последовательный поток и так далее соответственно а количество процессорных архитектур у нас практически бесконечное а что важно обычно архитектура

00:18:18	процессора - это именно что контракт по отношению к программисту который обязуется выполнять разработчик процессора для того чтобы тот мог решать свои задачи независимо вспоминаем одну из предыдущих лекций где я вам рассказывал про принципы развития ирахических систем Седова архитектур процессора - это зафиксированный уровень в рамках которого мы ограничиваем многообразие то есть мы говорим что у нас есть там N процессорных архитектур поверх которых мы уже строим наше программное обеспечение решаем наши

00:18:51	прикладные задачи а ввиду того что а когда мы говорим про архитектуру процессора она оказывает огромное влияние на инструментальную цепочку а современные проце компиляторы разрабатываются годами а сотнями тысячами людей а процесс архитектура она формирует целую огромную экосистему внутри которой идёт разработка и здесь у вас появляется необходимость противопоставить что-то архитектуре процессора как в платформе бейздизайне у вас есть центральная точка где сходится а-а application level то есть представление тех задач которые мы

00:19:29	решаем но и снизу у вас есть разные варианты того как этот интерфейс может быть реализован в результате у нас в оппозицию к понятию архитектура процессора которая фиксирует его внешние характеристики формируется понятие микроархитектура процессора где обычно под микроархитектурой понимается то а из каких агрегатов он состоит а как он должен на самом деле выполнять инструкции и то о чём мы с вами будем говорить на защите схем электрических по третьей лабораторке с ребятами которые будут делать четвёртую лабораторную

00:20:03	работу мы увидим что для одной и той же системы команды мы можем реализовать сотни если не тысячи разных микроархитектур которые одни будут более энергоэффективны другие будут более быстро работать третьи будут параллельные четвёртые будут ээ однопоточные и все эти конструкции позволяют нам реализовывать совершенно разные процессоры с разными акцентами и разными задачами по большому счёту аа сейчас в этих в этой группе лекции мы с вами больше будем говорить про архитектуру процессора то есть внешний

00:20:37	наблюдатель внешний интерфейс и как он влияет на программиста и как он влияет на общие там системные характеристики процессора дальше мы свалимся больше к вопросу микроархитектуры потому что там не знаю с точки зрения вашей программы ей в общем-то должно быть всё равно есть у вас кэширование или нет у вас кэширования в процессоре ей должно быть всё равно является ваш процессор суперскалярным конверизированным или нет соответственно а к деталям наполнению микроархитектуры процессора мы вернёмся немножко позже и центральное место

00:21:14	опять-таки появляются вот эти самые песочные часы а у нас занимает понятие системы команд то есть instruction set architecture где мы с вами по большому счёту фиксируем то какие данные могут обрабатываться какая должна быть модель памяти у нашего процессора то есть это одно адресное пространство или несколько видит пользователь ээ быструю память либо она работает прозрачно эээ как кэш это то какие наборы инструкций будут у вас в процессоре то есть можете вы складывать числа или только вычитать есть ли у вас операции на флотпоинтах

00:21:54	нет у вас операции на флотпоинтах далее у вас есть механизм обработки прерывания исключений то есть как ваш процессор может ломать а порядок вычислений вот из последовательного выходить в какие-то действия вызовы процедур а адресацию а косвенную прямую многие другие вопросы ну и пятый пункт наверное который сюда попадает - это то как идёт работа с сводом-вывода и вообще выделяется ли она во что-то особенное с точки зрения работы процессора в частности те из вас кто уже делал третью лабораторную работу наверняка заметили

00:22:32	что никаких специальных инструкций для работы с водом выводом у вас банально их нет потому что они там и не отрезатся аа отдельно здесь выделено слово машинное выделено понятие машинное слово это тот стандартный объём данных с которым работает процессор и которые ну как является вот этой стандартной единицей но к нему вернёмся ещё раз чуть-чуть позже здесь на схемке что на что стоит обратить внимание isa или система архитектуры процессора это это набор инструкций который у нас есть выше него для того чтобы с этой системой команд

00:23:09	работать на сегодня выстраивается огромное количество инструментальной цепочки где в первой идёт конечно например компилятор дальше у вас идёт язык программирования инструменталий для работы с вашим языком программирования только поверх этого вы уже будете писать свои приложения свои аппликации мы в этом курсе сваливаемся на уровень там между компилятором и ИСА чтобы как сказать потрогать и задаваться вопросами о том а какие системы команд есть а почему они есть такие или другие почему многие вещи в

00:23:40	разных системах команд делаются слегка безумными образами вы это наверняка те из вас кто уже тыкал систему командрии процессора а наверняка задавались такими вопросами ну или вам их задавали нижняя часть - это то как у нас построена микроархитектура процессора где у нас тракт обработки данных где у нас тракт управления какие узлы выполняют операции в нашем процессоре и всё это падает на уровень транзисторов и проводочков между ними то есть по большому счёту у нас круг замкнулся а мы начали с вами с релей реле максимально

00:24:20	простых механических устройств на них мы собрали ячейку памяти на них мы собрали простую логическую схему и дальше потихонечку потихонечку подбираясь вверх можно всегда подняться до системы команд и полностью убрать магический процесс из того как выполняются инструкции аа при этом а уровень разнообразия тех систем команд с которых мы можем работать ну он ну буквально бесконечен сейчас наверное в этом слайде мы не будем особенно в них влезать потому что практически все пункты которые здесь есть мы так или иначе

00:24:56	будем разбирать в лекциях дальше скажите у кого-нибудь есть какие-то вопросы тогда поехали дальше переходим к Собственно мы сказали что есть архитектура процессора есть микроархитектура процессора мы рассказали что у нас есть разные виды процессоров и центральное место вот которое мы сейчас будем рассматривать - это Central Process Unit то есть универсальный процессор который потенциально может решать любые задачи и при этом сделан максимально гибкий максимально программируемым дальше все всё остальное будем рассматривать скорее

00:25:35	как специализации из него собственно схематическое изображение машины по Неймона вы сейчас видите на слайде справа это очень простая конструкция где которая практически один в один повторяет то что мы с вами видели внутри информационного процессора единственный отличие который здесь можно видеть а у вас явно выделен Central Process Unit и в нём разделён Control Unit и Arithmetic Unit Logic Unit в русской это блок управления в русском языке обычно называется и арифметически логическое устройство а собственно что мы здесь

00:26:16	видим во-первых по большому счёту мы в очередной раз вернулись к машине тюринга единственное принципиальное отличие от машины тюринга в том что у нас есть memory unit вместо того что у нас есть бесконечные ленты по которой мы работаем что нам это даёт это даёт возможность адресовать ячейки памяти случайным образом а не ездя по ленте влево-вправо что гораздо быстрее и эффективнее происходит а второй момент мы объединяем команды инструкции и данные а классическая машинами она не делает никакого различия между ними

00:26:58	единственное что у неё есть у неё есть вот этот memory unit из которого можно прочитать и те действия которые нужно выполнить и те данные которые должны быть обработаны собственно там через слайд через два мы эти процессы будем смотреть более подробно в чём главная фишка данного процессора поскольку это как сказать вплод шестидесятых-пятидесятых годов именно тогда была придумана фонемская машина один из важных её критерией и фишек почему она была сделана такой какой она была сделана это максимальная простота в разработке

00:27:33	максимальная простота в реализации ээ лёгкость отладки лёгкость имплементации почему потому что тогда все эти вычислительные машины реально делались на реле это всё было очень э ненадёжно а у вас постоянно сбоились сами реле у вас постоянно отваливались контакты не было хороших припоев не было хорошей элементной базы из-за чего по большому счёту все процессора которые тогда создавались были таким уникальными творениями сегодня в значительной степени потому что тогда сформировались языки программирования эволюционным путём

00:28:13	тогда сформировалось представление о том а как вообще нужно программировать эти истории и мы до сих пор во многом попали в ту ловушку которая была тогда сформирована процессоромфонейна который стал а удивительно эффективным [музыка] удивительно как сказать аа ну наверное удивительно эффективным он настолько быстро вырвался вперёд на фоне всех остальных подходов и идей что по большому счёту захватил весь рынок и уйти от него нам сейчас практически невозможно там современное программирование а именно процедурное

00:28:49	программирование и объектноритированное программирование выстроено вокруг тех же самых идей тех же самых концепций что здесь имеется в виду под процедурным программированием у вас есть глобальное состояние вычительной машины представленные в виде кучи переменных которые существуют в отдельном контексте у вас есть э а лексический сколп переменных то есть это грубо говоря автоматические переменные которые вы определяете внутри функций и внутри текущего модуля и каждая выполняемая инструкция так или иначе ориентирована

00:29:23	на то чтобы изменить а память процессора данная в том самом меory Юните и каждая инструкция производит такой модификации абсолютно аналогичная история в объектнотивном программировании за тем исключением что на уровень программирования на уровень тех моделей с которыми работает наш программист у нас а происходит уже декомпозиция то есть мы говорим о том что у каждого объекта есть некоторое состояние это состояние принадлежит только ему соответственно мы говорим о том что у нас не любая инструкция может изменить любые данные

00:29:59	ли своём скопе а говорим о том что у нас есть некоторая область памяти и специальный набор инструкций который позволяет её поменять а и собственно это и легло в основы современного ОП если так можно говорить а чуточку подробней по ключевым особенностям машины фонеймона пробежимся первое а машина фонеймона использует двоичное кодирование машина фонеймана изначально строилась вокруг цифровой схемотехники и уже тогда двоичное кодирование стала основой всего да от этого тезиса конечно же есть исключение мы с вами говорили про

00:30:41	двоичнодестичные представления а можно найти упоминание в литературе про троичные ВМ которые в чём-то даже эффективнее машины Фонеймона можно увидеть как в современных ячейках памяти хранится не двоичное число а четырёхричное число потому что это позволяет а повысить эффективность упаковки данных и многие-многие вещи но базовое решение принятое тогда и до сих пор ставшее стандартным - это двоичное кодирование когда мы всю информацию представляем норликами единичками второй пункт - это программное управление а

00:31:18	именно то что у нас существует некоторый поток инструкций и данный поток инструкции определяет обучительный процесс нашего процессора то есть какие действия будут выполнены в следующем шаге и в следующем шаге и в следующем шаге соответственно это позволяет нам описывать простые линейные алгоритмы третий пункт - это память компьютера однородно хранит данные и программы собственно мы об этом с вами и говорили крайне удобно с точки зрения универсализации и с точки зрения гибкости когда данные не отличаются от

00:31:54	инструкций и в современном программировании я думаю вы довольно часто видели это на практике когда вы берёте замыкание вы берёте анонимную функцию передаёте её как параметр в другую функцию и у вас получается тот самый эффект когда вы начинаете перемешивать данные и инструкции все интерпретаторы так или иначе построены на этом принципе у вас читается файл файлы лежат по определению данные и дальше он начинает его как скажем так элемент за элементом токен за токеном выполнять и вычислять тут кстати

00:32:28	оставлен комментарий что однородность а-а данных и программ весьма спорна мы с вами этого более чем коснёмся возможно уже сегодня когда будем говорить о гавардской архитектуре и точно будем касаться в процессе обсуждения того как работают кши в современных процессорах потому что несмотря на то что данные программы суть одно и то же а практическая эффективность заставляет их разделять в рамках работы процессора четвёртый пункт - это ячейки памяти компьютера имеют адреса то самое random access memory мы не читаем бесконечность уже

00:33:07	данных мы всегда их можем так или иначе адресовывать а-а важный момент что в оригинальной архитектуре фонеймана память процессора была пассивным элементом что это значит это значит что в памяти было что Если в памяти что-то записано то это не может оттуда никуда деться вы всегда это можете прочитать вы всегда это можете записать память она у вас всегда под боку как блокнот который вы с которым вы не расстаётесь в современных реалиях это тоже не так современная память она не только имеет кучу своих внутренних процессов для того

00:33:40	чтобы оставаться в рабочем состоянии но и у вас в одну память начинает ломиться множество процессоров отсюда у вас появляется весь этот огромный ад проблем а вокруг мал программинг аа собственно возможны даже ситуации связанные отчасти с многопоточным программированием и не только когда у вас есть память и зависимо от того что вы будете читать из неё в разное время у вас будут оттуда вылетать разные данные как пример вы опять-таки вы можете с этим столкнуться в третьей лабораторной работе когда вы

00:34:17	работаете с водом-выводом как там это построено вы читаете ячейку памяти а туда подсовываются данные извода понятное дело что сколько раз вы прочитали столько раз вы получили разные данные оттуда ну и пятый пункт который делает всю эту историю тюринг полный который позволяет ей стать действительно универсальной - это возможности условного перехода когда ваш алгоритм перестаёт быть а строголинейным и начинает ветвиться в зависимости от ваших условий ваших задач ну и понятное дело в современном программировании это

00:34:45	доходит до совершенно магических историй когда за счёт полиморфизма у вас в зависимости от того типов данных с которыми вы работаете могут происходить совершенно безумные самые разные вещи скажите есть ли какие-то вопросы тогда поехали дальше а немножко в контекст а мы сказали о том что такое процессор фонеймана в реальной жизни надо немножко шагнуть выше и вспомнить общую терминологию чтобы сориентироваться и не путаться о том как это устроено собственно процессоров машина фонейма она почти всегда работает в окружении и первая

00:35:30	история которая есть - это понятие процессора и микропроцессор и обычно когда мы об этом говорим мы говорим исключительно о той части вычительной машины которая является вот этой самой числодробилкой в случае сфонеским процессом это вот Central Process Unit то есть тот кусок который работает с некоторой внешней а источником данных не внешними портами водовывода и может выполнять нашу задачу поэтому когда мы с вами говорим именно о процессоре или кто-то говорит о микропроцессоре мы почти всегда говорим только об этом

00:36:02	кусочке котором мы подскаче на память которая обычно физически или структурно разделена в чём принципиальное отличие о том что когда мы говорим о производстве иногда у нас CPU может включать в себя внешнюю память особенно это справедливо для микроконтроллеров которые выделение которых проведено здесь чуть-чуть пониже обычно это уже самодостаточная история там Ардуина это СТМы когда у вас есть процессор в нём уже сшита какая-то память с которой он может собственно решать ваши практические задачи тут надо заметить

00:36:38	что появляется достаточно тонкая грань потому что почти всегда в процессоре и вы это видели всё той же третил баторной работе у вас есть ещё и регистры которые казалось бы память но на самом деле являются неотъемлемой частью процессора потому что они не взаимозаменяемы относительно него как правило там выковырить из процессора регистра вы не можете а поставить туда меньшую внешнюю память вполне себе решаемая задача а оперативная память ну об этом мы с вами уже поговорили а теперь нырнём немножко

00:37:12	снова внутрь процессора когда мы смотрим на процессор особенно на фонеский процессор важно понимать что есть две противостоящие истории которые опять-таки в своё начало держат от машины Фонмана это противопоставление между контрол юнитом и датапасом это та часть которую вам нужно будет разделять когда вы будете делать третью лабораторку схемки и четвёртую лабораторную работу при проектировании потому что если вы всё это смешаете вместе у вас получится огромное мясо в котором будет практически невозможно

00:37:44	разобраться что это такое как правило в процессоре достаточно условно можно разделить как бы два плана бытия где у вас есть датапас - это та часть процессора которой реализуется сама машинерия по прикладному изменению данных то есть ваша задача- складывать числа ваша задача вычитать числа ваша задача умножать числа нас с точки зрения данного курса внутреннее устройство датапаса не интересует имеется в виду сами функциональные блоки вы нарисовали квадратик сказали что тут вы складываете два числа или инкрементируете число или

00:38:19	умножаете число нам не важно как это устроено внутри но нам важно понимать его структуру то есть а посмотреть на него как некоторую конструкцию внутри которого мы можем пересылать данные между регистрами и конечными операциями ээ совершать ээ преобразование данных чтение извода-вывода запись в вывод чтения из памяти переменных сложение их сохранения их обратно вопрос в том как эта машинерия реализуется и организована - это отдельный очень сложный вопрос потому что как правило в нём немножко хуже со структурами хотя некоторые вещи

00:39:01	конечно можно реализовать как мы ранее с вами говорили на прошлой лекции э есть в учительной технике такой приём описания учительного процесса как конечный автомат и по большому счёту конечный автомат - это та история которая а практически идеально описывает что такое Ctrl Unit и как он должен работать особенно в простейших случаях потому что Что значит выполнение инструкции вашим процессором это значит что процессор попадает в состояние исполнения инструкции допустим суммирования следующий шаг а вот эта инструкция

00:39:39	которую вы взяли она определяет то какие действия должны происходить там ближайшие пять тактов допустим чтение первого операнда чтение второго операнда а суммирование их запись результата вот у нас были выполнены вот эти четыре такта после этой инструкции согласно принципу последствий исполнения кода мы читаем данные из памяти это уже снова инструкция она снова меняет состояние нашего конечного автомата определяет новую цепочку состояние процессора в котором он будет собственно выполнять сходный

00:40:14	код скажите сложилось ли у вас какое-то понимание чем они отличаются или пока ещё достаточно мутно будем считать что сложилось а вторая часть вот мы разделили наш процессор на Control Unit и Dataпаs если мы посмотрим на Ctrl Unit то есть мозговой центр нашего процессора который управляет всей деятельностью определяет что должно происходить как должно происходить у нас мгновенно появляется а такой фактор как инструкция и её вид её формат потому что именно инструкция с точки зрения архитектуры процессора позволяет его

00:41:04	запрограммировать позволяет ему определить как должен свится учительный процесс и что мы здесь видим что любая инструкция так или иначе будет сводиться к тому чтобы как процессор должен взаимодействовать с памятью какие константы он должен знать откуда-то что он должен считать из памяти в регистре из регистра в памяти и и порты водовывода абсолютно однообразная структура а и все операции так или иначе вкладываются в эту историю конечно есть некоторые частные исключения как например вызов эксепшенов но тем не

00:41:40	менее всё это всегда можно свести к тому или иному изменению памяти а-а разделяют их по назначению у вас есть инструкции ориентированные в первую очередь на преобразование передачу информации между [музыка] разными видами памятей это операции направленные на преобразование данных то есть арифметические логические битовые операции это операции определяющие поток управления вашей программы то есть должна ли она следующей инструкции последовательно выполниться либо она должна проверить какое-то условие в

00:42:23	зависимости от этого у вас произойдёт условный переход и четвёртое - это отдельный класс он стоит особняком далеко не в картном процессоре присутствует поскольку современные процессора аа являются весьма большими сложными агрегатами очень часто для них цепляются внешние сопроцессоры то есть некоторые специализированный процессор который позволяет какую-то задачу решать очень эффективно там самый наверное яркий пример - это векторные супроцессоры которые позволяют вам однотипные операции на группе данных

00:42:58	выполнять намного быстрее чем если бы вы это делали в отдельном процессе опять-таки в конце курса мы такую такие примеры посмотрим здесь в правой части слайда вы можете видеть пример инструкции от процессора MIPS мм кто-ни кстати знает к какому семейству процессоров оно относится тишена это пример риск процессора м и здесь соответственно вы можете видеть инструкцию которая является тридцатидвухбитным словом внутри которой у вас есть четыре кусочка первоед - это код операции которая должна выполняться в данном случае это

00:43:42	операция ADE то есть добавление константы к какому-то заранее зафиксированному значению кстати обратите внимание что эта инструкция подозрительно напоминает ту инструкцию которая есть у вас в процессоре RIS F в 30 лабораторке у вас есть адресация двух регистров а из какого вы будете брать а то значение которому вы будете совершать сложение и тот регистр в который будет положен результат дальше собственно immediate value то значение которое у вас будет взято из инструкцией и использовано при сложении собственно здесь показано как

00:44:25	оно должно работать отдельным строчкой показана работа с лагом Overflow который у вас кстати вск 4 отсутствует а отдельно что нужно проговорить а-а в любом процессоре есть крауегольное понятие понятие машинного слова то есть это некоторая единица данных какого-то размера которая является естественной для архитектуры вашего процессора почему оно очень важно почему оно является прямо центральным первое а это та единица которая у вас точно должна быть адресуема внутри вашего процессора потому что если вы хотите

00:45:10	совершить операцию над какими-то данными над какими-то действиями единственный способ это сделать вам нужно взять адресовать те данные которые вы работаете это базовые принципы по номеровского процессора второй пункт а как правило когда мы говорим о машинном слове это та единица данных которая у вас может быть за один так за один раз за один такт а переда между процессором и памятью и соответственно у вас отсюда сразу же появляется тот эффективный размер единицы информации с которым может работать процессор потому

00:45:47	что если вы должны работать а там шестнадцатьюбитными числами а у вас машина слово 32 это значит что 16 бит вы будете таскать туда-сюда либо у вас будет просто простаивать кусок шины с которым вы работаете собственно а те ребята из вас которые работают со строками в третьей лабораторной работе наверняка успели немножко поплеваться из-за того что а адресация работает только машинными словами в тех процессорах с которые у вас есть и из-за этого приходится немножко прилагать дополнительные усилия чтобы всё работало корректно и что когда

00:46:27	вам нужно обратиться к отдельному байту вы это делали корректно а если же машиное слово меньше чем те данные которые вам нужны то понятное дело тоже проблема и для того чтобы сходить аэ за тридцатьдвухбитным числом при шестнадцатибитном машинном слове вам нужно сделать как минимум два такта а на самом деле обычно больше потому что вам нужно сначала адрисовать одно половинку машинс потом второго и всё это накладные расходы третий пункт является стандартная единица обрабатываемой информации то есть здесь у нас

00:47:02	используется параллелизм уровня бит то есть на уровне цифровой схемы комбинационных схем мы начинаем суммировать числа мы это делаем параллельно для отдельных битиков внутри этой истории ну и конечно же тут сразу же возникает группа связанных вопросов а именно: какие у нас форматы инструкций какие у нас форматы данных какие у нас форматы адресов и понятное дело что всё это не очень легко и не очень просто бьётся с размерами машинного слова почему потому что нам конечно бы хотелось чтобы у нас все инструкции влезали в машинное

00:47:36	слово потому что классно когда мы можем прочитать инструкцию за один такт в то же самое время это сразу же нам говорит о том что мы в инструкции не можем положить захардкоженные данные с которыми мы будем работать и мы не можем сложить туда полный адрес потому что возникает противоречие адрес вообще особенная история потому что у нас есть адресное пространство и у нас есть машинные слово которые могут между собой вообще и не соответствовать потому что ну современные компьютеры с которыми мы работаем у нас э размер

00:48:10	машинного сло бита а у кого есть 64 бита памяти ну не факт что есть у всего человечества если сложить всю память которую мы так или иначе произвели скажите есть ли какие-то вопросики нет так да поехали дальше кирилл да был вопрос вот по предыдущему слайду то есть по поводу опять же аронит и дата пафа то есть у нас к дата пафу относится ну следующий следующий где операция именно угу то есть у нас грубо говоря к датапафу относится арифметически логически работа с памятью а управляющие операции в том числе инструкции

00:48:56	спроцессоров - это contrtrolл юниты правильно это нельзя так однозначно сказать потому что это немножко разные истории когда мы говорим про Ctrl Unit Dataps то есть Ctrl Unit - это то что определяет какие действия будут происходить в процессоре но при этом они очень тесно взаимосвязаны иначе бы у вас не было условного оператора у вас есть датапас датас а-а вас формирует допустим те флаги которые управляют процессором ну например у вас же не может contrtrol Unit ээ понять ээ вы сложили два числа с переполнением или

00:49:34	без переполнения это задача второй части здесь наверное можно использовать такую аналогию как представить себе совершенно безрукого менеджера который определяет работу совершенно глупого исполнителя то есть он ему может сообщать: "Простейшая операция в духе: подними руку опусти руку возьми поставь" а но при этом сложные концепции там переложи из одной коробки в другую он уже описать не может у вас исполнитель такой но при этом менеджер наблюдает за тем что происходит потому что условно рабочему говорят: "Открой

00:50:23	коробку" менеджер смотрит пустая она или полная в зависит от этого он принимает следующее решение в этом смысле инструкция для сопроцессора у вас будет тракт данных внутри к этому тракту данных у вас будет подключён сопроцессор соответственно данные будут передаваться по датапасу обрабатываться и возвращаться назад надеюсь удалось прояснить да да стало понятнее спасибо кони а давайте посмотрим очень простой пример машины фонеймона и конкретной программки для него что-то подобное вы уже наверняка много раз видели то есть что

00:51:04	мы пока точно знаем о процессоре фанеймана у нас есть аа потерял слово у нас есть инструкции у нас их есть последовательность и у нас есть условный переход собственно что мы здесь можем с вами видеть у нас есть адреса в памяти у нас есть минимоники тех инструкций которые тут записаны по большому счёту то же самое в третьей лабораторке видите и комментарии которые пытаются хоть как-то объяснить что там происходит конкретно здесь проведена программа на Ассемблери X86 ителовского процессора и которая имеет возможность рассчитать ээ

00:51:51	факториал что мы тут с вами видим а мы видим работу с регистрами где у нас есть AX - это по-моему так основание то есть тот накопитель аккумулятор вокруг которого мы считаем вот эти квадратные скобочки- это чтение из памяти по адресу оттуда мы считаем то значение которое мы хотим а для которого мы хотим посчитать факториал аа dx - это два регистра которые парно нам позволяют представить результат умножения двух чисел ну собственно все помним что только факториал до 3 x 2 x 1 и так до нуля факториал от нуля должен быть равняться

00:52:27	единичке соответственно мы здесь видим набор инструкций которые шаг за шагом их выполнение должно привести к тому что у нас в регистрах ax и dx получится результат почему у вас здесь два регистра для результата хотя переумножаете вы два других всего по одному регистру то есть у вас операнда один регистр результат два регистра это связано с тем что при умножении вы можете получить в худшем случае удвоение количества а битов в результате собственно здесь на следующем слайде можно попытаться увидеть трассу

00:53:02	вот это процесса вот этой самой программки когда мы будем реально считать ээ а факториал тройки причём сразу же обращу внимание что здесь сделано немножко нечестно потому что теоретически аа процессор знать ничего не знает ни о какой структурном коде ни о каких циклах он просто выполняет инструкцию за инструкции у него нет никакого дополнительного контекста здесь же так сказать графически аа была сделана попытка сделать так чтобы этот алгоритм было всё-таки чуточку легче и чуточку проще читать соответственно выполнение нашей

00:53:40	программы настройка процессора для того чтобы он решал ту задачу которая нужно она заключается в том что мы в регистре процессора то есть те данные которые наиболее быстро наиболее просто аа изменять обрабатывать мы их помещаем в наши регистры собственно у нас их там три штучки: cx AX DX а где CX один множитель а X наш аккумулятор вместе с DX идут парами после чего у нас начинается наша операция мы выполняем умножение а и выполняем операцию Loop достаточно хитрая операция которая сразу же действует делает достаточно много

00:54:20	действий она декрементирует значение в регистре проверяет его на равенство нулю и в случае если не равно нулю то прыгает по джампу если нет мы проваливаемся дальше к следующему шагу соответственно поскольку мы считаем факториал тройки мы делаем три итерации а в конечном счёте а наше значение CX превращается в ноль это позволяет нам зарегистрировать состояние что мы выполнили все нужные нам численные операции и после этого мы можем покинуть наш цикл соответственно результат может быть сохранён в течение

00:54:57	чи памяти которые нужен произошло за пределами штука максимально простая максимально деревянная а что мы можем сказать про машину именно сегодня на практике понятное дело что вот этот пример который мы здесь посмотрели а именно система команд X86 - это не классический процессор Aйon слишком много чего умеет слишком много регистров вообще есть регистры хотя оригинальная машина должна была работать только с памятью и её адресацией если мы посмотрим там чуть более обще мы вспомним что у нас в xде6

00:55:34	есть э а параллелизм система прерываний наша память не является пассивной у нас есть система водовывода напрямую в память ДМА у нас есть мэширование много-много другого но тем не менее мы можем говорить о том что в современном мире машина оказала прямо колоссальное и огромное влияние на то что мы имеем на практике а в чистом виде её нет но тем не менее опять-таки всё до языков программирования выстроено от неё и в значительной степени ориентировано на неё отдельно хочется отметить что такая её как чудовищная популярность создала

00:56:19	для нас одновременно и кучу проблем ввиду того что работает эффект масштаба а знаете что это такое предположительно да ну да пример примерно понимаю попробуйте сформулировать ну я могу сформулировать с точки зрения какой-нибудь рекламы что например если ты делаешь рекламу для одной вещи то там тысяча добавится к одной вещи а если ты там делаешь для целой для сотни тысяч вещей то вообще цена на одну будет очень маленькая или это другое имеется в виду нене не всё всё верно абсолютно туда куда надо попали а если мы говорим про

00:57:03	современные процессора то это огромный инструментарий сложнейший это инструментальные цепочки производства самих процессоров их программирования и это не говоря про самую ужасный аспект а тысячи и миллионы программистов которые не будут пользоваться вашим каким бы классным язык программирования не был если у него нету всеподобного синтаксиса там посмотрите сколько людей плюётся от языка программирования Python потому что в нём вместо фигурных скобочек используются отступы хотя казалось бы какая разница

00:57:38	мы даже при процессоре писали которые позволяют писать все стильные питончики хотя не очень понятно зачем аа здесь я делаю небольшую ссылочку на прекрасную работу а именно тюринговую лекцию такого чувачка как Бекус Джон Бекус кто-нибудь знает кто это за что ему тюринга дали ну он создал да ещё ещё он сделал является одним из авторов формы Бокуса Наура который описывает синтаксис с языка на которыю так или иначе вы смотрите на спеку какого-нибудь дженовского пакета Джейсона вообще любой синтаксиса почти

00:58:22	всегда кус Наур где-то там очень рядышком потому что ну как это один из тех человек человеков который создал нашу индустрию и уже в семьдесят седьмом году он был озадачен машиной фонеймона тем насколько она чудовищно популярна и как мы туда проваливаемся и сделал тюринговую лекцию на тему: сможем ли мы когда-нибудь освободиться с точки зрения программирования от стиля фоннеймана от подхода к организации учительного процесса фонеймона потому что этот дядька уже тогда понимал к чему всё ведёт и какие проблемы это создаёт

00:59:03	кстати давайте попробуем чуть-чуть откатиться а-а можете пытаться сформулировать какие-то недостатки данного процессора просто из этой схемы вот этой верхней одно из ключевых проблем здесь уже в общем-то видно даже две возможно как раз-таки объединённая память команд и данных а мы об этом поговорим чуть-чуть дальше подробно но вообще нет ну скажем так связано но нет ещё версия возможно разделение ввода выводы и памяти нет на самом деле тоже нет не проблемы это как сказать особенность может быть проблема масштабирования

00:59:58	а что вы в это вкладываете ну я там немного наперёд смотрел там про то как организуется работа сразу нескольких процессоров другими словами он поразувает что у вас архитектуры нема вроде как захочет мысль нельзя скажем так больше сделать и чтобы это было адекватно то есть в современных компьютерах вроде как ограниче Ну в пользоских компьютерах там не особо много ядер ну то есть возможно где-то в этом проблема ну тут я бы сформулировал это немножко вас переформулирую а эта архитектура подразумевает что у вас есть один Ctrl

01:00:35	unниit который работает с памятью соответственно эта архитектура не очень подразумевает когда у вас этих контрол юнитов много а парелизм - это собственно то немногое что нам необходимо чтобы процессоры хорошо работали и шахбос у нас бутылочное горлышко в области где процессор общается с памятью поскольку у нас отмена одна и та же шина используется для захвата и инструкций и данных ну опять-таки здесь друг друга бортся здесь нет проблемы в том что и инструкции данных здесь проблема в том что у вас одна память то есть грубо

01:01:07	говоря у вас есть вот эта вот шина взаимодействия между ними и мы ещё отдельно с вами поговорим о такой проблеме как Memory Wall из-за которой там современные процессоры не очень можно ускорять но опять-таки мы до этого ещё доберёмся не так быстро как хотелось бы или нормально в общем доберёмся соответственно стиль программирования который нам задала машина ФН вот этот пошаговое исполнение инструкций которая прямо противоречит параллеризму а доступ к памяти который прямо противоречит тоже проилизму потому что как-то

01:01:44	разграничение доступов - это то что вам необходимо при проверенном вычислениях это единый канал к памяти потому что у него есть ограниченная пропускная способность какая бы большой она не была и и и вспомню в следующий раз вылетела из головы итак соответственно если мы посмотрим на процессор фнеймана а в классическом виде он почти не встречается но у него есть огромное количество разных вариаций это памяти команд памяти данных как они организованы единая это память или разные и также что это за памяти потому

01:02:25	что у нас может быть память унифицированная для данных мы можем по-разному хранить разные данные мы можем по-разному адресовывать адресные пространства в которых мы можем адресовывать там классический пример когда у вас есть пространство адресов регистров пространство адресов памяти и пространство адресов портов водовывода у вас могут быть разные машины слова вплоть до того что у вас память вообще может быть тегированная что означает что у вас каждой ячейке памяти приделан небольшой маркер относительно того что

01:02:56	это такое инструкция это данные это адрес ли это и так далее так кстати вспомнил то что вылетело с головы аа проблема безопасности потому что когда вы не можете различить инструкцию перед вами или данных вы можете начать выполнять данные как инструкцию а инструкцию как данные и да здравствует огромное количество уязвимостей в програмном печении которое было создано как раз-таки именно из-за этого второй пункт чем они могут различаться а принцип работы вашего датапаса а в классическом фонрском процессоре ваш датапас - это то что

01:03:32	уходит в память аа берёт оттуда данные и записывает обратные результаты всё по факту же у нас есть аккумуляторные архитектуры это то что у вас было на базовой ВМ когда у вас всё идёт через одну ячейку памяти через один аккумулятор и вы начинаете вот так вот через неё перекидывать данные то что вы в третьей лабораторке в аккумуляторной архитектуре наверняка на моялись сделать когда на каждый чих вам сохранил в память прочитал в память сохранил в память прочитал память сделал малейшее действие опять сохранил в память

01:04:02	прочитал что-то другое и прочее истории такого толка это датапасы построенные на регистррегистр операциях когда единственное что вы можете сделать это вы можете приоблизовать те данные которые у вас хранятся в регистре то что есть в модных сегодня популярных рискпроцессорах потому что а вы не можете взять а прочитать данные из памяти и приплюсовать их сразу же в одной инструкции к значению в регистре просто такое запрещено register to memory в общем-то плюс-минус то же самое но у вас уже чуть больше

01:04:35	операций самые классные с точки зрения assembler программистов - это memory to memory операции ну представьте себе вы говорите о том что: "А теперь пожалуйста возьми значение из этой ячейки памяти из этой ячейки памяти результат положи в эту ячейку памяти" причём ещё по какой-нибудь косвенной адресации вообще красота и самая большая экзотика которая вам всем будет ломать мозг это стековые процессора в которых у вас нету регистров а вы все операции выполняете на стейке и соответственно в третьей

01:05:06	лаборатории работе вы с этим сможете или будете вынуждены поиграться третий пункт мощность систем команд то есть то какое количество операций инструкции вам предоставлено как программисту и тут конечно же сразу же вспоминаются слова которых вы слышали которые мы будем рассматривать подробнее циск и риск процессоры где цик - это complex instruction set controller а риск - это reduced instruction set controller где у вас а количество операций максимально обрублено во имя каких-то непонятных мыслей разработчиков

01:05:41	процессоров ну и соответственно здесь у вас они могут варьироваться по количеству операций кто-нибудь кстати может вот ноль операндов вспоминаем стекковую архитектуру вы наверняка замечали что у вас в явном виде ни одной инструкции или практически ни одной инструкции оперант ни в каком виде не передаётся потому что ну нет такой необходимости он просто подразумевает что он лежит на стеке вы всегда его можете там взять он не требует никакой адресации это то как эти инструкции кодируются и принцип построения нашего

01:06:09	контрол юнита конечно же потому что ну опять-таки чуть дальше мы это с вами рассмотрим и конечно же бесконечное количество практически вариаций построенных вокруг того как мы адресуем наши операнты от самых простых вариантов когда мы просто знаем что один из оперантов лежит там-то например аккумуляторная архитектура всегда знает что любое действие будет так или иначе связано с аккумулятором то есть он подразумевается а это непосредственная адресация когда мы захардкоживаем значение внутри нашей инструкции

01:06:44	допустим инициализировать регистр значением 17 цифру 17 мы вкарткоживаем в инструкцию прямая м тут я кстати сейчас немно А прямая адресация имеется в виду когда мы указываем адрес ячейки памяти с которой мы работаем то есть непосредственно говорим: "Либо это регистр либо это ячейка памяти" относительная когда у нас идёт операция со смещением это то о чём я вас регулярно спрашиваю в третьей лабораторной работе в Близкопцесарах что там за ноль перед адресацией странной стоит укороченная часть адреса которая у

01:07:21	нас есть в аккумуляторной архитектуре и в рисковой косвенная адресация это индирект то есть когда мы читаем не из той ячейки в которой нужно а смотрит там адрес чтобы его в конечном счёте прочитать адресация слов переменной длины стековая автонгрементная автодекрементная собственно и то и то мы сегодня видели стековая примерно понятно автоинкрементное и автодекрементное - это то что мы видели в факториале когда мы прочитали значение и автоматически его либо увеличили на единичку либо уменьшили ну и конечно же большой список

01:07:54	вопросов вариативности который прямо пока что у нас входит за контекст так скажите есть ли какие-то вопросики сейчас тогда если мне не изменяет память мы нырнём вот в этот вопрос нет мы Гарварскую и пристанскую скорее всего сейчас занырвнём поехали итак как некоторые из вас сегодня сказали о том что главный недостаток процессора архитектуры заключается в том что у нас один канал и для данных и для информации в принципе вы были правы и вы не первые это заметили потому что как практически сразу же после процессоров

01:08:33	фонеймона возник вопрос: "А зачем нам а давайте мы как-нибудь всё-таки мухи отдельно котлеты отдельно давайте мы будем работать с памятью в одном месте с данными в другом месте и появилась так называемая Гарвардская архитектура внутри которой у нас ээ была предложена идея о том что давайте это будут физически две разные памяти памяти программ мы будем хранить исключительной инструкции то что мы будем пода читать записывать в Ctrl Unit он это будет интерпретировать и управлять нашей машинерией на датапасе а дата будет в

01:09:09	свою очередь подключён к data memory и соответственно там он будет работать со своими данными это нам даёт на самом деле э очень много классных историй ну например а у нас появляется два канала доступа в память мы получаем гораздо более быструю историю нам э мы автоматически защищены с точки зрения информационной безопасности мы не можем случайно начать выполнять данные у нас всё строго разграничено заложено по полочкам а по такому обзорному сравнению чем они хороши чем они плохи два физических канала лучше чем один никто я

01:09:51	думаю спорить не будет второе одновременный доступ к памяти мы с вами это посмотрим в при конвейерной организации процессора когда мы можем в один такт одновременно и прочитать операн для одной инструкции и прочитать следующую инструкцию нам не нужно стоять и ждать пока нам канал данных будет освобождён третье разная ширина машинного слова и адреса для данных и программ а например мы хотим в наших инструкциях э легко инициализировать константы а для датапаса у нас тридцатидвухбитное машинное слово для в

01:10:26	датапасе мы делаем инструк машинное слово инструкции 48 бит где у нас сверху лежит окод и полностью тридцатьбитное слово ну классно же мы прочитали инструкции сразу же положили данные в память ээ данных записали и у нас всё произошло всё хорошо нам не нужно с этим заморачиваться нам не нужно магическим образом инициализировать константы в памяти как это делается сейчас в теwayм процессоре нам чтобы получить единичку для инкремента или декремента на мы вынуждены выделить в памяти данных место и сохранить там эту

01:11:06	константку ну и четвёртое собственно изоляция недостатки тоже я думаю в принципе понятно и интуитивно первое - это сложность и стоимость реализации две памяти больше чем одна а процессор который вынужден работать с двумя шинами в общем случае будет сложнее чем процессор который работает с одной шиной а у вас возникает много дизайнерских вопросов например а а какое у вас должно быть адресное пространство для инструкций а какое адресное пространство должно быть для данных хватит ли вам 16 бито адресации в данных или же 16 и 32 в

01:11:42	инструкциях или их надо поменять а как вы думаете а что быстрее растёт: адресное пространство инструкций или адресное пространство данных при решении задач представим себе что у вас было шестнадцатибитное адресное пространство и там и там где вы быстрее увеличите его до 24 бит поразмышляйте на эту историю ну в данных почему ну мы можем с разными данными одно и то же делать как когда факториал считаем угу ну вот смотрите в примере с факториалом у вас здесь адресная память данных раз три слова а инструкций вон

01:12:42	сколько на самом деле здесь нету правильного ответа правильный ответ здесь звучит примерно так зависит от того какую задачу вы решаете и мы впрямую свалимся в вопрос о том а говорим мы там о информационной системе или управляющей системе например если вы делаете архиватор там вам в первую очередь нужна а память данных потому что вы хотите заархивировать допустим ну то есть позк он пришёл с каким-то объёмом данных он хочет его заархивировать у вас есть фиксированный алгоритм который будет выполняться против любого объёма данных

01:13:24	какой пользователь бы не принёс и как известно алгоритмы у вас эти теория информации была как курс нет пока а будет или не знаете нет наверное мы не знаем жалко надеюсь будет по идее это должно быть на первом втором курсе где-то там в самом начале а в общем как вы узнаете я надеюсь на курсе теории информации а все архиваторы работают примерно по одному принципу они находят какие-то похожести в вашем файле и как предлагают шорткаты для них соответственно в общем случае справедливое утверждение что чем больше

01:14:11	окно данных которые вы рассматриваете чтобы сформировать этот словарик подмен тем эффективнее ваш архиватор соответственно в случае с информационными системами как правило у вас объём данных будет расти гораздо быстрее в то же самое время если мы говорим про управляющие системы то обычно они к чему сводятся у вас есть очень сложные алгоритмы управления а и дальше у вас есть там три АЦП на входе которые просто очень быстро вам выплёвывают данные вам нужно хранить историю допустим из пяти замеров на

01:14:49	котором вы считаете какие-то фильтры значений и у вас количество данных там строго фиксировано а вот дописать постфактум при программировании вашего контроллера новый алгоритм улучшить поведение вашего шумадава в наушниках или что-нибудь такое вполне себе нужная операция поэтому здесь нет универсального ответа как оно должно быть ну и на самом деле на практике есть довольно забавное наблюдение о том что в информационных системах в универсальных системах как правило лучше будет работать вам пристаннская архитектура

01:15:21	или фоневская архитектура где с памяти объединены а в специальном применении а в встроенных системах системах управления чаще часто встречается гавардская архитектура потому что ну более чем достаточно и решение получается чуть более безопасно а второй такой фундаментальный недостаток гаровской архитектуры возникает в следующем анской процессор он самодостаточен у вас один и тот же процессор может быть и инструментальным и целевым то есть вы можете сами сгенерировать программу и сами её выполнить у вас нет вот этого

01:15:58	переходного процесса а как мы данные из диска прочитаем интерпретируем как инструкцию если это просто данные у вас нету проблемы перекачки данных из одной одного типа памяти в другую это такая фундаментальная проблема которая в газоской архитектуре там где она стоит её можно решать только костылями там где этой проблемы нет ээ идеальное применение для гавардской архитектуры соответственно некоторые вариации которые позволяют решать эту проблему это память инструкции как данных то есть вы можете из инструкций перечитать всё

01:16:33	внутрь в информацию в лоб а вторая - это память данных как инструкция соответственно обратная последованость обратная инструкция ну и понятное дело что цена у этих двух историй она достаточно большая потому что а от того что вы использ одну память как другую вы убиваете все плюсы Гарвардской архитектуры у вас нарушается изоляция у вас исчезает второй канал и вообще непонятно зачем был нужен весь этот сырбор что на практике у вас реализуется сегодня вот в центральных процессорах в тех компьютерах которые стоят сейчас

01:17:11	перед нами в них по большому счёту используется так называемая модифицированная гарна гарнская архитектура с точки зрения адресации мы рассматриваем всю память как единую но тракты получения данных у вас разные и за счёт системы кэширования за счёт того что мм мы читаем из разных мест данные инструкции они редко когда пересекаются прямо момент в моменте мы можем кэшировать доступы и с точки зрения самого ядра процессора как правило для него это выглядит как гарвардская архитектура но с точки зрения такого общего уровня это

01:17:54	имитируется она Она как скажем так она реализуется полностью на уровне микроархитектуры на уровне архитектуры процессора она обычно а не проявляется скажите есть ли какие-то вопросики хорошо а смотрите сейчас у нас осталось 8 минуток и надо разобрать по большому счёту пять этих принципов поэтому давайте мы с вами сейчас сделаем следующим образом мы на этом лекцию закончим в следующий раз я вас может на эти самые 10 минут такко и задержу и мы сразу же начнём с принципов работы с данными в датапасе и все вот

01:18:35	эти пять пунктиков разберём на примерчиках как оно работает как оно выглядит и дальше уже занырнём насколько я помню в конкретику машинерии работы конкретного аккумуляторного процессора поэтому давайте сейчас если есть какие-то вопросы вы можете задать если нет ээ 5 минут перерыв и будет консультация по четвёртой лабораторной работе для желающих есть какие-то вопросики да кирилл а можно задать вопрос по поводу ээ ну не по поводу именно темы лекции хотел спросить будет ли запись вот этой консультации по четвёртой

01:19:14	лабораторной или нет а смысла нет потому что когда идут частные консультации там как правило они слишком контекстно зависимые и ну это не имеет практической значимости если же вы сами придёте с вопросом и захотите записать с вы предупредите меня чтобы я вам нажал кнопку "Да разреш разрешаю ввести запись" и можете её сделать для себя лично если вам будет потом удобно можете её там расшарить в чатике просто вот эти организационные вопросы заберите на себя угу о'кей спасибо ещё вопросики отлично тогда на сегодня мы

01:19:54	закончили я останавливаю запись yeah


3.
(слайды)
(сам сказал)

4.
(слайды)
(сам сказал)

5.
(слайды)
(сам сказал)

6.
(слайды)
(сам сказал)

7.
(слайды)
(сам сказал)

8.
(слайды)
(сам сказал)

9.
(слайды)
(сам сказал)

10.
(слайды)
(сам сказал)

1.
(слайды)
(сам сказал)